<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üîß Correction - Acc√®s Lectures en Attente</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f5f5;
        }
        .container {
            background: white;
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            margin-bottom: 20px;
        }
        .header {
            text-align: center;
            color: #2563eb;
            border-bottom: 2px solid #e5e7eb;
            padding-bottom: 20px;
            margin-bottom: 30px;
        }
        .section {
            margin: 20px 0;
            padding: 20px;
            border-radius: 8px;
            border-left: 4px solid #3b82f6;
            background-color: #f8fafc;
        }
        .section h3 {
            margin-top: 0;
            color: #1e40af;
        }
        .btn {
            background-color: #3b82f6;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            margin: 5px;
            font-size: 14px;
        }
        .btn:hover {
            background-color: #2563eb;
        }
        .btn-danger {
            background-color: #dc2626;
        }
        .btn-danger:hover {
            background-color: #b91c1c;
        }
        .btn-success {
            background-color: #16a34a;
        }
        .btn-success:hover {
            background-color: #15803d;
        }
        .btn-warning {
            background-color: #f59e0b;
        }
        .btn-warning:hover {
            background-color: #d97706;
        }
        .result {
            margin-top: 15px;
            padding: 15px;
            border-radius: 5px;
            background-color: #f1f5f9;
            border-left: 4px solid #64748b;
            white-space: pre-wrap;
            font-family: monospace;
            font-size: 12px;
        }
        .success {
            background-color: #f0fdf4;
            border-left-color: #16a34a;
            color: #166534;
        }
        .error {
            background-color: #fef2f2;
            border-left-color: #dc2626;
            color: #991b1b;
        }
        .warning {
            background-color: #fffbeb;
            border-left-color: #f59e0b;
            color: #92400e;
        }
        .status {
            display: inline-block;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 12px;
            font-weight: bold;
            margin-left: 10px;
        }
        .status.online {
            background-color: #dcfce7;
            color: #166534;
        }
        .status.offline {
            background-color: #fee2e2;
            color: #991b1b;
        }
        .grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
        }
        .grid-3 {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 15px;
        }
        @media (max-width: 768px) {
            .grid, .grid-3 {
                grid-template-columns: 1fr;
            }
        }
        .force-access-section {
            border-left-color: #f59e0b;
            background-color: #fffbeb;
        }
        .force-access-section h3 {
            color: #92400e;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üîß Diagnostic et Correction</h1>
            <p>R√©solution du probl√®me d'acc√®s aux formulaires depuis "Lectures en Attente"</p>
            <div id="connectionStatus">
                <span>Connexion Supabase: </span>
                <span id="statusIndicator" class="status offline">V√©rification...</span>
            </div>
        </div>

        <div class="grid">
            <div class="section">
                <h3>üîç 1. Diagnostic</h3>
                <p>Identifier les probl√®mes dans la navigation lectures ‚Üí formulaire</p>
                <button class="btn" onclick="runDiagnostic()">Lancer le diagnostic</button>
                <div id="diagnosticResult" class="result" style="display: none;"></div>
            </div>

            <div class="section">
                <h3>üìã 2. Donn√©es de test</h3>
                <p>Cr√©er des donn√©es de test pour v√©rifier le fonctionnement</p>
                <button class="btn btn-success" onclick="createTestData()">Cr√©er donn√©es de test</button>
                <div id="testDataResult" class="result" style="display: none;"></div>
            </div>

            <div class="section">
                <h3>üîó 3. Test navigation</h3>
                <p>Tester la navigation depuis lectures en attente vers formulaire</p>
                <button class="btn" onclick="testNavigation()">Tester navigation</button>
                <div id="navigationResult" class="result" style="display: none;"></div>
            </div>

            <div class="section">
                <h3>üßπ 4. Nettoyage</h3>
                <p>Nettoyer les donn√©es corrompues si n√©cessaire</p>
                <button class="btn btn-danger" onclick="cleanDatabase()">Nettoyer base</button>
                <div id="cleanResult" class="result" style="display: none;"></div>
            </div>
        </div>

        <div class="section force-access-section">
            <h3>‚ö° 5. Forcer l'acc√®s (ignorer les dates)</h3>
            <p>Permettre l'acc√®s aux formulaires m√™me si ce n'est pas la bonne date de lecture</p>
            <div class="grid-3">
                <button class="btn btn-warning" onclick="enableForceAccess()">Activer acc√®s forc√©</button>
                <button class="btn" onclick="checkCurrentAccess()">V√©rifier acc√®s actuel</button>
                <button class="btn btn-danger" onclick="disableForceAccess()">D√©sactiver acc√®s forc√©</button>
            </div>
            <div id="forceAccessResult" class="result" style="display: none;"></div>
        </div>

        <div class="section">
            <h3>üìù 6. Rapport complet</h3>
            <p>G√©n√©rer un rapport d√©taill√© des probl√®mes et solutions</p>
            <button class="btn" onclick="generateReport()">G√©n√©rer rapport</button>
            <div id="reportResult" class="result" style="display: none;"></div>
        </div>
    </div>

    <script type="module">
        import { createClient } from 'https://esm.sh/@supabase/supabase-js@2';

        // Configuration Supabase
        const supabaseUrl = 'https://ekmkjbqafhjkuqhjdslf.supabase.co';
        const supabaseKey = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImVrbWtqYnFhZmhqa3VxaGpkc2xmIiwicm9sZSI6InB1YmxpYyIsImlhdCI6MTczMzg2OTY2MSwiZXhwIjoyMDQ5NDQ1NjYxfQ.xzQQHaM2KPV-21z1MuJOkRm5qn4FQvFjy--R_BwD3zs';
        const supabase = createClient(supabaseUrl, supabaseKey);

        // Variables globales
        window.supabase = supabase;
        window.testData = {};

        // V√©rifier la connexion au chargement
        window.addEventListener('load', checkConnection);

        // Fonction pour v√©rifier la connexion
        async function checkConnection() {
            try {
                const { data, error } = await supabase.from('samples').select('count').limit(1);
                const statusElement = document.getElementById('statusIndicator');
                
                if (error) {
                    statusElement.textContent = 'Hors ligne';
                    statusElement.className = 'status offline';
                } else {
                    statusElement.textContent = 'En ligne';
                    statusElement.className = 'status online';
                }
            } catch (error) {
                const statusElement = document.getElementById('statusIndicator');
                statusElement.textContent = 'Erreur';
                statusElement.className = 'status offline';
            }
        }

        // 1. Fonction de diagnostic
        window.runDiagnostic = async function() {
            const resultDiv = document.getElementById('diagnosticResult');
            resultDiv.style.display = 'block';
            resultDiv.className = 'result';
            resultDiv.textContent = 'üîç Diagnostic en cours...\n';

            try {
                let report = '=== DIAGNOSTIC LECTURES EN ATTENTE ===\n\n';

                // 1. V√©rifier les √©chantillons en attente de lecture
                report += 'üìä 1. √âCHANTILLONS EN ATTENTE:\n';
                const { data: waitingSamples, error: waitingError } = await supabase
                    .from('samples')
                    .select('form_id, report_title, brand, site, status, created_at')
                    .eq('status', 'waiting_reading');

                if (waitingError) {
                    report += `‚ùå Erreur: ${waitingError.message}\n`;
                } else {
                    report += `‚úÖ ${waitingSamples.length} √©chantillons trouv√©s\n`;
                    waitingSamples.forEach((sample, i) => {
                        report += `   ${i+1}. Form: ${sample.form_id} | Titre: ${sample.report_title}\n`;
                    });
                }

                // 2. V√©rifier les bact√©ries associ√©es
                report += '\nü¶† 2. BACT√âRIES ASSOCI√âES:\n';
                const { data: bacteria, error: bacteriaError } = await supabase
                    .from('form_bacteria_selections')
                    .select('*')
                    .in('status', ['pending', 'in_progress']);

                if (bacteriaError) {
                    report += `‚ùå Erreur: ${bacteriaError.message}\n`;
                } else {
                    report += `‚úÖ ${bacteria.length} bact√©ries trouv√©es\n`;
                    bacteria.forEach((b, i) => {
                        report += `   ${i+1}. ${b.bacteria_name} (${b.form_id}) - ${b.status}\n`;
                        
                        // V√©rifier si la date est dans le futur (cause du blocage)
                        const createdDate = new Date(b.created_at);
                        const now = new Date();
                        const delayHours = parseInt(b.bacteria_delay.replace(/[^\d]/g, '')) || 24;
                        const readingDate = new Date(createdDate.getTime() + delayHours * 60 * 60 * 1000);
                        
                        if (readingDate > now) {
                            const hoursLeft = Math.ceil((readingDate - now) / (1000 * 60 * 60));
                            report += `      ‚ö†Ô∏è  Acc√®s bloqu√©: encore ${hoursLeft}h avant lecture\n`;
                        }
                    });
                }

                // 3. V√©rifier les correspondances
                report += '\nüîó 3. CORRESPONDANCES:\n';
                if (waitingSamples && bacteria) {
                    const sampleFormIds = waitingSamples.map(s => s.form_id);
                    const bacteriaFormIds = bacteria.map(b => b.form_id);
                    const matches = sampleFormIds.filter(id => bacteriaFormIds.includes(id));
                    
                    report += `‚úÖ ${matches.length} correspondances trouv√©es\n`;
                    matches.forEach(id => report += `   - ${id}\n`);
                    
                    const orphanSamples = sampleFormIds.filter(id => !bacteriaFormIds.includes(id));
                    const orphanBacteria = bacteriaFormIds.filter(id => !sampleFormIds.includes(id));
                    
                    if (orphanSamples.length > 0) {
                        report += `‚ö†Ô∏è  ${orphanSamples.length} √©chantillons sans bact√©ries:\n`;
                        orphanSamples.forEach(id => report += `   - ${id}\n`);
                    }
                    
                    if (orphanBacteria.length > 0) {
                        report += `‚ö†Ô∏è  ${orphanBacteria.length} bact√©ries sans √©chantillons:\n`;
                        orphanBacteria.forEach(id => report += `   - ${id}\n`);
                    }
                }

                // 4. Probl√®mes identifi√©s
                report += '\nüö® 4. PROBL√àMES IDENTIFI√âS:\n';
                const problems = [];
                
                if (!waitingSamples || waitingSamples.length === 0) {
                    problems.push('Aucun √©chantillon en attente de lecture');
                }
                if (!bacteria || bacteria.length === 0) {
                    problems.push('Aucune bact√©rie en attente');
                }
                if (waitingSamples && bacteria) {
                    const sampleFormIds = waitingSamples.map(s => s.form_id);
                    const bacteriaFormIds = bacteria.map(b => b.form_id);
                    const orphanSamples = sampleFormIds.filter(id => !bacteriaFormIds.includes(id));
                    const orphanBacteria = bacteriaFormIds.filter(id => !sampleFormIds.includes(id));
                    
                    if (orphanSamples.length > 0) {
                        problems.push(`${orphanSamples.length} √©chantillons orphelins`);
                    }
                    if (orphanBacteria.length > 0) {
                        problems.push(`${orphanBacteria.length} bact√©ries orphelines`);
                    }

                    // V√©rifier les blocages de date
                    const blockedBacteria = bacteria.filter(b => {
                        const createdDate = new Date(b.created_at);
                        const now = new Date();
                        const delayHours = parseInt(b.bacteria_delay.replace(/[^\d]/g, '')) || 24;
                        const readingDate = new Date(createdDate.getTime() + delayHours * 60 * 60 * 1000);
                        return readingDate > now;
                    });
                    
                    if (blockedBacteria.length > 0) {
                        problems.push(`${blockedBacteria.length} bact√©ries bloqu√©es par contrainte de date`);
                    }
                }

                if (problems.length === 0) {
                    report += '‚úÖ Aucun probl√®me d√©tect√©\n';
                } else {
                    problems.forEach(problem => report += `‚ùå ${problem}\n`);
                }

                resultDiv.textContent = report;
                resultDiv.className = 'result success';

                // Stocker les donn√©es pour les autres fonctions
                window.testData.waitingSamples = waitingSamples;
                window.testData.bacteria = bacteria;

            } catch (error) {
                resultDiv.textContent = `‚ùå Erreur lors du diagnostic: ${error.message}`;
                resultDiv.className = 'result error';
            }
        };

        // 2. Fonction pour cr√©er des donn√©es de test
        window.createTestData = async function() {
            const resultDiv = document.getElementById('testDataResult');
            resultDiv.style.display = 'block';
            resultDiv.className = 'result';
            resultDiv.textContent = 'üß™ Cr√©ation des donn√©es de test...\n';

            try {
                let report = '=== CR√âATION DONN√âES DE TEST ===\n\n';

                // Cr√©er un formulaire de test avec √©chantillons
                const testFormId = `TEST-FORM-${Date.now()}`;
                const testReportTitle = `Test Lecture - ${new Date().toLocaleString('fr-FR')}`;

                report += `üìã Cr√©ation du formulaire: ${testFormId}\n`;

                // 1. Cr√©er des √©chantillons de test
                const testSamples = [];
                for (let i = 1; i <= 3; i++) {
                    testSamples.push({
                        number: i.toString().padStart(2, '0'),
                        product: 'Yaourt Test',
                        form_id: testFormId,
                        report_title: testReportTitle,
                        status: 'waiting_reading',
                        brand: 'Test Brand',
                        site: 'Test Site',
                        fabrication: new Date().toISOString().split('T')[0],
                        dlc: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000).toISOString().split('T')[0],
                        smell: 'C',
                        texture: 'C',
                        taste: 'C',
                        aspect: 'C',
                        created_at: new Date().toISOString(),
                        modified_at: new Date().toISOString()
                    });
                }

                const { data: samplesInserted, error: samplesError } = await supabase
                    .from('samples')
                    .insert(testSamples)
                    .select();

                if (samplesError) {
                    throw new Error(`Erreur √©chantillons: ${samplesError.message}`);
                }

                report += `‚úÖ ${samplesInserted.length} √©chantillons cr√©√©s\n`;

                // 2. Cr√©er des bact√©ries de test (une accessible maintenant, une dans le futur)
                const now = new Date();
                const pastDate = new Date(now.getTime() - 25 * 60 * 60 * 1000); // Il y a 25h
                const recentDate = new Date(now.getTime() - 1 * 60 * 60 * 1000); // Il y a 1h

                const testBacteria = [
                    {
                        form_id: testFormId,
                        bacteria_name: 'E. coli',
                        bacteria_delay: '24h',
                        reading_day: 'Lundi',
                        status: 'pending',
                        created_at: pastDate.toISOString(), // Cr√©√© il y a 25h = accessible maintenant
                        modified_at: pastDate.toISOString()
                    },
                    {
                        form_id: testFormId,
                        bacteria_name: 'Listeria',
                        bacteria_delay: '48h',
                        reading_day: 'Mardi',
                        status: 'pending',
                        created_at: recentDate.toISOString(), // Cr√©√© il y a 1h = pas encore accessible
                        modified_at: recentDate.toISOString()
                    }
                ];

                const { data: bacteriaInserted, error: bacteriaError } = await supabase
                    .from('form_bacteria_selections')
                    .insert(testBacteria)
                    .select();

                if (bacteriaError) {
                    throw new Error(`Erreur bact√©ries: ${bacteriaError.message}`);
                }

                report += `‚úÖ ${bacteriaInserted.length} bact√©ries cr√©√©es\n`;

                report += `\nüéØ DONN√âES DE TEST CR√â√âES:\n`;
                report += `Form ID: ${testFormId}\n`;
                report += `Titre: ${testReportTitle}\n`;
                report += `√âchantillons: ${samplesInserted.length}\n`;
                report += `Bact√©ries: ${bacteriaInserted.length}\n`;
                report += `\nüìÖ STATUT D'ACC√àS:\n`;
                report += `- E. coli: ‚úÖ Accessible (cr√©√© il y a 25h)\n`;
                report += `- Listeria: ‚ùå Bloqu√© jusqu'√† demain (cr√©√© il y a 1h)\n`;

                // Stocker les donn√©es de test
                window.testData.testFormId = testFormId;
                window.testData.testSamples = samplesInserted;
                window.testData.testBacteria = bacteriaInserted;

                resultDiv.textContent = report;
                resultDiv.className = 'result success';

            } catch (error) {
                resultDiv.textContent = `‚ùå Erreur lors de la cr√©ation: ${error.message}`;
                resultDiv.className = 'result error';
            }
        };

        // 3. Fonction pour tester la navigation
        window.testNavigation = async function() {
            const resultDiv = document.getElementById('navigationResult');
            resultDiv.style.display = 'block';
            resultDiv.className = 'result';
            resultDiv.textContent = 'üîó Test de navigation en cours...\n';

            try {
                let report = '=== TEST DE NAVIGATION ===\n\n';

                // V√©rifier si on a des donn√©es de test
                if (!window.testData.testBacteria || window.testData.testBacteria.length === 0) {
                    report += '‚ö†Ô∏è  Aucune donn√©e de test. Cr√©ez d\'abord des donn√©es de test.\n';
                    resultDiv.textContent = report;
                    resultDiv.className = 'result error';
                    return;
                }

                // Simuler la s√©lection d'une bact√©rie
                const testBacteria = window.testData.testBacteria[0];
                report += `ü¶† Test avec: ${testBacteria.bacteria_name}\n`;
                report += `Form ID: ${testBacteria.form_id}\n`;

                // 1. Marquer la bact√©rie comme "in_progress"
                const { error: updateError } = await supabase
                    .from('form_bacteria_selections')
                    .update({
                        status: 'in_progress',
                        modified_at: new Date().toISOString()
                    })
                    .eq('id', testBacteria.id);

                if (updateError) {
                    report += `‚ùå Erreur mise √† jour: ${updateError.message}\n`;
                } else {
                    report += `‚úÖ Bact√©rie marqu√©e comme "in_progress"\n`;
                }

                // 2. V√©rifier que les √©chantillons existent
                const { data: formSamples, error: samplesError } = await supabase
                    .from('samples')
                    .select('*')
                    .eq('form_id', testBacteria.form_id);

                if (samplesError) {
                    report += `‚ùå Erreur √©chantillons: ${samplesError.message}\n`;
                } else {
                    report += `‚úÖ ${formSamples.length} √©chantillons trouv√©s pour ce formulaire\n`;
                }

                // 3. Simuler la navigation
                const navigationState = {
                    formId: testBacteria.form_id,
                    bacterie: testBacteria.bacteria_name,
                    comingFromReadingPage: true,
                    reportTitle: `Lecture de ${testBacteria.bacteria_name}`,
                    delai: testBacteria.bacteria_delay,
                    jour: testBacteria.reading_day,
                    forceAccess: true // Nouveau param√®tre pour forcer l'acc√®s
                };

                report += `\nüöÄ PARAM√àTRES DE NAVIGATION:\n`;
                Object.entries(navigationState).forEach(([key, value]) => {
                    report += `   ${key}: ${value}\n`;
                });

                // 4. Tester l'URL de navigation
                const testUrl = new URL('/sample-entry', window.location.origin);
                report += `\nüìç URL de destination: ${testUrl.href}\n`;

                // 5. Cr√©er un lien de test
                report += `\nüîó LIEN DE TEST G√âN√âR√â:\n`;
                const testLink = `${window.location.origin}/sample-entry?formId=${testBacteria.form_id}&bacterie=${encodeURIComponent(testBacteria.bacteria_name)}&delai=${testBacteria.bacteria_delay}&jour=${encodeURIComponent(testBacteria.reading_day)}&forceAccess=true`;
                report += `${testLink}\n`;

                report += `\n‚úÖ Test de navigation termin√© avec succ√®s!\n`;
                report += `üí° Vous pouvez maintenant tester en acc√©dant √†: http://localhost:3000/lectures-en-attente\n`;

                resultDiv.textContent = report;
                resultDiv.className = 'result success';

            } catch (error) {
                resultDiv.textContent = `‚ùå Erreur lors du test: ${error.message}`;
                resultDiv.className = 'result error';
            }
        };

        // 4. Fonction de nettoyage
        window.cleanDatabase = async function() {
            const resultDiv = document.getElementById('cleanResult');
            resultDiv.style.display = 'block';
            resultDiv.className = 'result';
            resultDiv.textContent = 'üßπ Nettoyage en cours...\n';

            try {
                let report = '=== NETTOYAGE BASE DE DONN√âES ===\n\n';

                // 1. Supprimer les donn√©es de test
                const { error: testSamplesError } = await supabase
                    .from('samples')
                    .delete()
                    .like('form_id', 'TEST-FORM-%');

                const { error: testBacteriaError } = await supabase
                    .from('form_bacteria_selections')
                    .delete()
                    .like('form_id', 'TEST-FORM-%');

                if (testSamplesError || testBacteriaError) {
                    report += `‚ö†Ô∏è  Erreur partielle lors du nettoyage\n`;
                } else {
                    report += `‚úÖ Donn√©es de test supprim√©es\n`;
                }

                // 2. Nettoyer les bact√©ries orphelines
                report += `\nüßπ Nettoyage des bact√©ries orphelines...\n`;
                
                // R√©cup√©rer tous les form_ids des √©chantillons
                const { data: allSamples } = await supabase
                    .from('samples')
                    .select('form_id');

                const sampleFormIds = allSamples ? [...new Set(allSamples.map(s => s.form_id))] : [];

                // Supprimer les bact√©ries qui n'ont pas d'√©chantillons correspondants
                if (sampleFormIds.length > 0) {
                    const { error: orphanError } = await supabase
                        .from('form_bacteria_selections')
                        .delete()
                        .not('form_id', 'in', `(${sampleFormIds.map(id => `'${id}'`).join(',')})`);

                    if (orphanError) {
                        report += `‚ö†Ô∏è  Erreur nettoyage orphelines: ${orphanError.message}\n`;
                    } else {
                        report += `‚úÖ Bact√©ries orphelines supprim√©es\n`;
                    }
                } else {
                    report += `‚úÖ Pas de bact√©ries orphelines √† nettoyer\n`;
                }

                report += `\n‚úÖ Nettoyage termin√©!\n`;

                resultDiv.textContent = report;
                resultDiv.className = 'result success';

            } catch (error) {
                resultDiv.textContent = `‚ùå Erreur lors du nettoyage: ${error.message}`;
                resultDiv.className = 'result error';
            }
        };

        // 5. Fonction pour activer l'acc√®s forc√©
        window.enableForceAccess = async function() {
            const resultDiv = document.getElementById('forceAccessResult');
            resultDiv.style.display = 'block';
            resultDiv.className = 'result warning';
            resultDiv.textContent = '‚ö° Activation de l\'acc√®s forc√©...\n';

            try {
                let report = '=== ACTIVATION ACC√àS FORC√â ===\n\n';

                // Mettre √† jour toutes les bact√©ries pour qu'elles soient accessibles
                const { data: allBacteria, error: fetchError } = await supabase
                    .from('form_bacteria_selections')
                    .select('*')
                    .in('status', ['pending', 'in_progress']);

                if (fetchError) {
                    throw new Error(`Erreur lors de la r√©cup√©ration: ${fetchError.message}`);
                }

                report += `üìä ${allBacteria.length} bact√©ries trouv√©es\n\n`;

                if (allBacteria.length > 0) {
                    // Forcer toutes les bact√©ries √† √™tre "pr√™tes" en modifiant leur date de cr√©ation
                    const pastDate = new Date(Date.now() - 7 * 24 * 60 * 60 * 1000); // Il y a 7 jours

                    for (const bacteria of allBacteria) {
                        const { error: updateError } = await supabase
                            .from('form_bacteria_selections')
                            .update({
                                created_at: pastDate.toISOString(),
                                modified_at: new Date().toISOString()
                            })
                            .eq('id', bacteria.id);

                        if (updateError) {
                            report += `‚ùå Erreur pour ${bacteria.bacteria_name}: ${updateError.message}\n`;
                        } else {
                            report += `‚úÖ ${bacteria.bacteria_name} (${bacteria.form_id}) ‚Üí Acc√®s forc√© activ√©\n`;
                        }
                    }
                } else {
                    report += '‚ö†Ô∏è  Aucune bact√©rie trouv√©e √† d√©bloquer\n';
                }

                report += `\n‚ö° ACC√àS FORC√â ACTIV√â!\n`;
                report += `üéØ Toutes les bact√©ries sont maintenant accessibles ind√©pendamment de leur date\n`;
                report += `üí° Allez sur http://localhost:3000/lectures-en-attente pour tester\n`;

                resultDiv.textContent = report;
                resultDiv.className = 'result success';

            } catch (error) {
                resultDiv.textContent = `‚ùå Erreur lors de l'activation: ${error.message}`;
                resultDiv.className = 'result error';
            }
        };

        // 6. Fonction pour v√©rifier l'acc√®s actuel
        window.checkCurrentAccess = async function() {
            const resultDiv = document.getElementById('forceAccessResult');
            resultDiv.style.display = 'block';
            resultDiv.className = 'result';
            resultDiv.textContent = 'üîç V√©rification de l\'acc√®s...\n';

            try {
                let report = '=== √âTAT ACTUEL DES ACC√àS ===\n\n';

                const { data: bacteria, error } = await supabase
                    .from('form_bacteria_selections')
                    .select('*')
                    .in('status', ['pending', 'in_progress']);

                if (error) {
                    throw new Error(`Erreur: ${error.message}`);
                }

                report += `üìä ${bacteria.length} bact√©ries en attente\n\n`;

                const now = new Date();
                let accessibleCount = 0;
                let blockedCount = 0;

                bacteria.forEach((b, i) => {
                    const createdDate = new Date(b.created_at);
                    const delayHours = parseInt(b.bacteria_delay.replace(/[^\d]/g, '')) || 24;
                    const readingDate = new Date(createdDate.getTime() + delayHours * 60 * 60 * 1000);
                    
                    const isAccessible = readingDate <= now;
                    const hoursLeft = isAccessible ? 0 : Math.ceil((readingDate - now) / (1000 * 60 * 60));
                    
                    report += `${i+1}. ${b.bacteria_name} (${b.form_id})\n`;
                    report += `   Cr√©√©: ${new Date(b.created_at).toLocaleString('fr-FR')}\n`;
                    report += `   Statut: ${isAccessible ? '‚úÖ Accessible' : `‚ùå Bloqu√© (${hoursLeft}h restantes)`}\n\n`;
                    
                    if (isAccessible) {
                        accessibleCount++;
                    } else {
                        blockedCount++;
                    }
                });

                report += `üìà R√âSUM√â:\n`;
                report += `‚úÖ Accessibles: ${accessibleCount}\n`;
                report += `‚ùå Bloqu√©es: ${blockedCount}\n`;

                if (blockedCount > 0) {
                    report += `\nüí° TIP: Utilisez "Activer acc√®s forc√©" pour d√©bloquer toutes les bact√©ries\n`;
                }

                resultDiv.textContent = report;
                resultDiv.className = blockedCount > 0 ? 'result warning' : 'result success';

            } catch (error) {
                resultDiv.textContent = `‚ùå Erreur lors de la v√©rification: ${error.message}`;
                resultDiv.className = 'result error';
            }
        };

        // 7. Fonction pour d√©sactiver l'acc√®s forc√©
        window.disableForceAccess = async function() {
            const resultDiv = document.getElementById('forceAccessResult');
            resultDiv.style.display = 'block';
            resultDiv.className = 'result';
            resultDiv.textContent = 'üîí D√©sactivation de l\'acc√®s forc√©...\n';

            try {
                let report = '=== D√âSACTIVATION ACC√àS FORC√â ===\n\n';

                // Remettre les bact√©ries √† leur date de cr√©ation normale
                const { data: allBacteria, error: fetchError } = await supabase
                    .from('form_bacteria_selections')
                    .select('*')
                    .in('status', ['pending', 'in_progress']);

                if (fetchError) {
                    throw new Error(`Erreur: ${fetchError.message}`);
                }

                if (allBacteria.length > 0) {
                    for (const bacteria of allBacteria) {
                        // Remettre la date de cr√©ation √† maintenant (pour respecter les d√©lais normaux)
                        const { error: updateError } = await supabase
                            .from('form_bacteria_selections')
                            .update({
                                created_at: new Date().toISOString(),
                                modified_at: new Date().toISOString()
                            })
                            .eq('id', bacteria.id);

                        if (updateError) {
                            report += `‚ùå Erreur pour ${bacteria.bacteria_name}: ${updateError.message}\n`;
                        } else {
                            report += `‚úÖ ${bacteria.bacteria_name} ‚Üí D√©lais normaux restaur√©s\n`;
                        }
                    }
                } else {
                    report += '‚ö†Ô∏è  Aucune bact√©rie trouv√©e\n';
                }

                report += `\nüîí ACC√àS FORC√â D√âSACTIV√â!\n`;
                report += `‚è∞ Les bact√©ries respectent maintenant leurs d√©lais normaux\n`;

                resultDiv.textContent = report;
                resultDiv.className = 'result success';

            } catch (error) {
                resultDiv.textContent = `‚ùå Erreur lors de la d√©sactivation: ${error.message}`;
                resultDiv.className = 'result error';
            }
        };

        // 8. Fonction pour g√©n√©rer le rapport (mise √† jour)
        window.generateReport = async function() {
            const resultDiv = document.getElementById('reportResult');
            resultDiv.style.display = 'block';
            resultDiv.className = 'result';
            resultDiv.textContent = 'üìù G√©n√©ration du rapport...\n';

            try {
                let report = '=== RAPPORT COMPLET - LECTURES EN ATTENTE ===\n\n';

                // Date du rapport
                report += `üìÖ G√©n√©r√© le: ${new Date().toLocaleString('fr-FR')}\n\n`;

                // √âtat actuel de la base
                report += 'üìä √âTAT ACTUEL DE LA BASE:\n';
                
                const { data: allSamples } = await supabase.from('samples').select('status');
                const { data: allBacteria } = await supabase.from('form_bacteria_selections').select('status, created_at, bacteria_delay');

                if (allSamples) {
                    const statusCount = allSamples.reduce((acc, sample) => {
                        acc[sample.status] = (acc[sample.status] || 0) + 1;
                        return acc;
                    }, {});
                    
                    report += '   √âchantillons par statut:\n';
                    Object.entries(statusCount).forEach(([status, count]) => {
                        report += `   - ${status}: ${count}\n`;
                    });
                }

                if (allBacteria) {
                    const bacteriaStatusCount = allBacteria.reduce((acc, bacteria) => {
                        acc[bacteria.status] = (acc[bacteria.status] || 0) + 1;
                        return acc;
                    }, {});
                    
                    report += '   Bact√©ries par statut:\n';
                    Object.entries(bacteriaStatusCount).forEach(([status, count]) => {
                        report += `   - ${status}: ${count}\n`;
                    });

                    // Analyser les acc√®s bloqu√©s
                    const now = new Date();
                    let blockedCount = 0;
                    allBacteria.forEach(b => {
                        if (b.status === 'pending') {
                            const createdDate = new Date(b.created_at);
                            const delayHours = parseInt(b.bacteria_delay?.replace(/[^\d]/g, '') || '24');
                            const readingDate = new Date(createdDate.getTime() + delayHours * 60 * 60 * 1000);
                            if (readingDate > now) {
                                blockedCount++;
                            }
                        }
                    });
                    
                    if (blockedCount > 0) {
                        report += `   ‚ö†Ô∏è  Bact√©ries bloqu√©es par date: ${blockedCount}\n`;
                    }
                }

                // Probl√®mes identifi√©s et solutions
                report += '\nüîß PROBL√àMES ET SOLUTIONS:\n\n';
                
                report += '1. PROBL√àME: Impossible d\'acc√©der aux formulaires depuis "Lectures en attente"\n';
                report += '   CAUSE: √âchantillons sans bact√©ries associ√©es ou vice versa\n';
                report += '   SOLUTION: Cr√©er des donn√©es coh√©rentes avec ce script\n\n';

                report += '2. PROBL√àME: Navigation React qui ne fonctionne pas\n';
                report += '   CAUSE: √âtat localStorage supprim√© mais logique de navigation non adapt√©e\n';
                report += '   SOLUTION: Utiliser uniquement les param√®tres React Router state\n\n';

                report += '3. PROBL√àME: Chargement des √©chantillons qui √©choue\n';
                report += '   CAUSE: loadSamplesByFormId ne trouve pas les √©chantillons\n';
                report += '   SOLUTION: V√©rifier que form_id correspond entre samples et bacteria\n\n';

                report += '4. PROBL√àME: Acc√®s bloqu√© par contrainte de date\n';
                report += '   CAUSE: Les bact√©ries ne sont accessibles qu\'apr√®s leur d√©lai (24h, 48h, etc.)\n';
                report += '   SOLUTION: Utiliser la fonction "Forcer l\'acc√®s" pour ignorer les d√©lais\n\n';

                // Recommandations
                report += 'üí° RECOMMANDATIONS:\n\n';
                report += '‚úÖ 1. Toujours cr√©er des √©chantillons ET des bact√©ries avec le m√™me form_id\n';
                report += '‚úÖ 2. Utiliser le script de cr√©ation de donn√©es de test avant de tester\n';
                report += '‚úÖ 3. V√©rifier la coh√©rence des donn√©es avec le diagnostic\n';
                report += '‚úÖ 4. Tester la navigation apr√®s chaque modification\n';
                report += '‚úÖ 5. Utiliser "Forcer l\'acc√®s" pour tester sans attendre les d√©lais\n\n';

                // Instructions d'utilisation
                report += 'üöÄ INSTRUCTIONS D\'UTILISATION:\n\n';
                report += '1. Cliquez sur "Lancer le diagnostic" pour identifier les probl√®mes\n';
                report += '2. Cliquez sur "Cr√©er donn√©es de test" pour avoir des donn√©es coh√©rentes\n';
                report += '3. Cliquez sur "Activer acc√®s forc√©" pour ignorer les contraintes de date\n';
                report += '4. Cliquez sur "Tester navigation" pour v√©rifier le fonctionnement\n';
                report += '5. Acc√©dez √† http://localhost:3000/lectures-en-attente pour tester\n';
                report += '6. Utilisez "Nettoyer base" pour supprimer les donn√©es de test\n';
                report += '7. Utilisez "D√©sactiver acc√®s forc√©" pour remettre les d√©lais normaux\n\n';

                report += '‚úÖ RAPPORT TERMIN√â\n';

                resultDiv.textContent = report;
                resultDiv.className = 'result success';

            } catch (error) {
                resultDiv.textContent = `‚ùå Erreur lors de la g√©n√©ration: ${error.message}`;
                resultDiv.className = 'result error';
            }
        };
    </script>
</body>
</html> 